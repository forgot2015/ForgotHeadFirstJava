# ForgotHeadFirstJava
HeadFirstJava 笔记

## 第一章 基本概念(P1~26)
基本语句，if else, for循环, while循环
````
public class Main {

    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
````
## 第二章 拜访对象村(P28~47)
- 面向过程编程和面向对象编程的区别。 面向对象的可扩展性强，在需求不断更改的时候仍能很好地扩展，而面向过程则会改动很大
- 类的继承，方法重写。
- 对象是类的一个实例

## 第三章 认识变量(P49~69)
- 变量的声明，需指定变量的类型，new对象时类型不对会报错
- 8中基本类型，byte,short,int,long,float,double,boolean,char
- 类型的转换，如int转long，String转float,注意long转int时有可能溢出，导致值变化
- java关键字，变量命名不能与关键字重名
- 垃圾回收堆，常量池，栈
- 数组也是对象
- Java里的是引用传递，而不是值传递

## 第四章 对象的行为(P70~94)
- 对象的行为和状态（方法和实例变量）。对象影响行为，行为印象状态
- 方法中的返回值,如int String , Object类型
- 方法的参数，向方法中传入多个参数 (Object... args)
- void方法可以没有返回值
- Java的封装，实例变量用修饰符private,用getter和setter方法来保证变量安全性（如可在setter方法中进行限制，检查参数是否能执行），而且改变封装的方法，不会影响到他人的引用，若直接修改变量的话，改动就大了。而直接存取变量对效率的提高并没那么大
- 实例变量和局部变量。 实例变量是在类内的变量，有默认值，可以不初始化就引用。而局部变量是在方法内的变量，没有默认值，若不初始化就引用，会报错
- 用==来判别两个引用是否都指向同一个对象，重写equal和hashcode方法来判断是否值相同
-
## 第五章 超强力方法 （P95~123）
- 随机数的产生 Math.random()产生0~1的随机数
- 开发的步骤：伪代码->测试码->真实码
- 找出类应该做的事->列出实例变量和方法->编写伪代码->编写测试用例->实现方法->测试->优化改Bug->重构
- 伪代码关键是处理方法逻辑，也可画流程图来代替
- 先编写测试用例的概念来自于极限编程XP
- 为何要先写测试方法？思索和编写测试用例时能否帮助你了解被测的程序应该要做哪些事情，写完代码后就能测试结果。 另外，若不先写测试用例，以后也不会再写了。。。 理想中，先写一部分测试用例，然后进行一部分编码，如此循环
- 如果知道要执行多少次时，最好用for循环或foreach循环，而不是while

## 第六章 使用Java函数库(P124~164)
- ArrayList,LinkedList,HashMap,HashSet的常用方法
- 数组在创建时就必须确定大小，而ArrayList可以动态改变大小
- 布尔表达式 与&&  或|| 非！  不等于!=   
- 位运算符 & |
- 使用函数库的方法，导入包import Package, 或者直接声明全名，java.util.ArrayList list = new java.util.ArrayList();
- javax开头的包,是官方认可的扩展包，为了减少程序的改动，所以没有将类包含到java包中
- java.lang包内的类不用导入包就能直接使用，因为java.lang是个预先被引用的包
- 如何查询API，一是要知道库中有哪些类，二是要知道这些类的用途。故只能多看资料

## 第七章 继承与多态（P165~196)
- 基类和派生类，或者说父类和子类
- 找出具有共同属性和行为的对象，设计代表共同状态和行为的类，决定子类是否让某项行为有特定不同的运作方式，将子类再进行分类，修改继承层次
- 当调用对象引用的方法时，会优先调用最低阶的方法，若没有，则一直往父类去寻找对应方法
- 当决定某物是否应该要继承另一物时，可以用IS-A测试，如三角形是多边形，所以应该继承，但澡盆不是浴室，所以不该继承，只是有关联而已
- 继承的意义，代码复用，减少重复代码。 定义出共同的协议
- 对象的声明，创建和赋值
- 在多态下，引用与对象可以是不同的类型，如Animal myDog = new Dog();
此时的myDog是一个Dog对象，但只能使用Animal中包含的方法，而这些方法的实现确实Dog中的
- 参数和返回类型也可以多态
- 方法重写Override和方法重载Overload

## 第八章 接口和抽象类